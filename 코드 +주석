# pandas 모듈은 데이터를 표(엑셀처럼 다룰 수 있는 구조)로 읽고 처리할 수 있게 해줍니다.
# 이 코드에서는 CSV 파일로 저장된 취업 정보를 불러오고, 데이터를 정리 및 검색할 수 있도록 도와줍니다.
import pandas as pd

# JobDataManager 클래스는 데이터를 읽고 정리하고, 필요한 데이터를 추출하는 역할을 합니다.
# 이 코드에서는 데이터를 효율적으로 관리하기 위해 데이터를 읽고 처리하는 모든 작업을 이 클래스가 담당합니다.
class JobDataManager:
    """데이터 로드 및 관리 클래스"""

    def __init__(self, main_file_path, sector_file_paths):
        # 이 코드에서는 전체 취업 정보 파일 경로(main_file_path)와 분야별 파일 경로(sector_file_paths)를 저장합니다.
        # 이 정보를 저장해두면 데이터를 로드하거나 검색할 때 파일 경로를 참조할 수 있기 때문에 필요합니다.
        self.main_file_path = main_file_path  # 전체 취업 정보가 들어있는 파일 경로
        self.sector_file_paths = sector_file_paths  # 분야별 취업 정보 파일 경로들을 저장

        # 이 코드에서는 데이터를 저장하기 위한 공간으로 초기값을 None으로 설정합니다.
        # 데이터가 아직 로드되지 않았음을 명확히 나타내기 위해 필요합니다.
        self.main_data = None  # 전체 데이터가 저장될 변수
        self.sector_data = None  # 분야별 데이터를 합친 결과가 저장될 변수

    def load_data(self):
        """데이터 로드 및 통합"""
        # 이 코드에서는 pandas를 사용하여 main_file_path에서 전체 취업 정보를 읽어옵니다.
        # 읽어온 데이터는 self.main_data에 저장되며, 분야별 요약 정보 제공을 위해 사용됩니다.
        self.main_data = pd.read_csv(self.main_file_path, encoding='euc-kr')

        # 이 코드에서는 분야별 데이터를 하나의 데이터로 합치기 위해 사용되었습니다.
        # 각 파일을 읽고, '분야' 열을 추가해 데이터 출처를 표시하며, 모든 데이터를 self.sector_data에 통합합니다.
        self.sector_data = pd.concat(
            [pd.read_csv(path, encoding='euc-kr').assign(분야=name)
             for name, path in self.sector_file_paths.items()],  # 딕셔너리의 키(name)와 값(path)을 반복
            ignore_index=True  # 합친 데이터에 새로운 번호를 부여하여 일관성을 유지합니다.
        )

    def filter_data(self, **conditions):
        """조건에 따라 데이터 필터링"""
        # 이 코드에서는 self.sector_data에서 특정 조건에 맞는 데이터를 골라내기 위해 사용됩니다.
        # 조건에 맞는 데이터만 반환하여 사용자가 필요한 정보만 확인할 수 있도록 돕습니다.
        df = self.sector_data
        for col, val in conditions.items():  # 전달받은 조건(예: 분야, 기업명 등)을 하나씩 적용합니다.
            df = df[df[col] == val]  # 조건에 맞는 데이터만 남깁니다.
        return df  # 조건에 맞는 결과를 반환합니다.

# JobAssistant 클래스는 사용자와 상호작용하며 데이터를 출력하고, 사용자가 원하는 정보를 쉽게 찾을 수 있도록 돕습니다.
# 이 코드에서는 사용자가 데이터를 직접 다루지 않고, 메뉴를 통해 원하는 정보를 탐색할 수 있도록 하기 위해 사용되었습니다.
class JobAssistant:
    """사용자 인터페이스 관리 클래스"""

    def __init__(self, manager):
        # 이 코드에서는 JobDataManager 객체(manager)를 연결하여 데이터를 검색하고 출력할 수 있도록 설정합니다.
        # 데이터 관리를 분리함으로써 역할을 명확히 하고, 코드 구조를 개선하기 위해 필요합니다.
        self.manager = manager

    def get_user_input(self, prompt, options):
        """사용자 입력 헬퍼 함수"""
        # 이 코드에서는 사용자에게 선택지를 보여주고, 사용자의 입력을 받아 선택된 값을 반환합니다.
        print(prompt)  # 사용자가 선택해야 할 내용을 출력합니다.
        for i, option in enumerate(options, 1):
            # 이 코드에서는 enumerate를 사용하여 선택지에 번호를 붙여 보기 좋게 출력합니다.
            print(f"{i}. {option}")
        try:
            # 사용자가 입력한 번호를 정수로 변환하고, 선택이 유효한 범위에 있는지 확인합니다.
            choice = int(input("\n번호를 선택하세요: "))
            if 1 <= choice <= len(options):
                return options[choice - 1]  # 유효한 선택이면 해당 옵션을 반환합니다.
        except ValueError:
            # 사용자가 잘못된 값을 입력했을 경우 프로그램이 멈추지 않도록 예외 처리를 합니다.
            pass
        print("유효한 번호를 입력해주세요.")  # 잘못된 입력에 대한 경고 메시지 출력
        return None  # 유효하지 않은 입력일 경우 None을 반환합니다.

    def show_sector_summary(self):
        """분야별 요약 정보 출력"""
        # 이 코드에서는 사용자가 특정 분야를 선택하고, 해당 분야의 요약 정보를 출력하기 위해 사용되었습니다.
        print("\n분야를 선택하세요:")
        # 사용자가 선택할 수 있는 분야 목록을 출력하고 선택을 요청합니다.
        sector = self.get_user_input(
            "관심 있는 분야를 선택하세요:", self.manager.main_data['분야'].tolist()
        )
        if sector:
            # 사용자가 선택한 분야의 데이터를 가져와 출력합니다.
            summary = self.manager.main_data[self.manager.main_data['분야'] == sector].iloc[0]
            print(f"\n===== {sector} =====")
            # 선택된 분야에 대한 주요 정보를 출력합니다.
            print(f"**주요 직무**: {summary['주요 직무']}")
            print(f"**취업 가능 기업**: {summary['취업 가능 기업']}")
            print(f"**필요 역량/기술**: {summary['필요 역량/기술']}")
            print(f"**추천 자격증**: {summary['추천 자격증']}")
            print(f"**추천 MBTI**: {summary['추천 MBTI']}")

    def show_company_jobs(self):
        """기업별 채용 공고 출력"""
        # 이 코드에서는 사용자가 특정 분야를 선택하고, 해당 분야의 기업별 채용 공고를 출력하기 위해 사용되었습니다.
        print("\n분야를 선택하세요:")
        # 사용자가 선택할 수 있는 분야 목록을 출력합니다.
        sector = self.get_user_input(
            "관심 있는 분야를 선택하세요:", self.manager.sector_data['분야'].unique()
        )
        if sector:
            # 선택한 분야에 속한 기업 리스트를 가져옵니다.
            companies = self.manager.filter_data(분야=sector)['기업명'].unique()
            # 사용자가 선택할 수 있도록 기업 목록을 출력합니다.
            company = self.get_user_input(f"[{sector}]의 기업을 선택하세요:", companies)
            if company:
                # 선택된 기업의 채용 공고 데이터를 가져옵니다.
                details = self.manager.filter_data(분야=sector, 기업명=company)
                print(f"\n===== [{company}] 채용 공고 =====")
                for _, row in details.iterrows():
                    # 기업의 모든 채용 공고 정보를 보기 좋게 출력합니다.
                    print(f"\n**채용 직무/분야**: {row['채용 직무/분야']}")
                    print(f"**주요 업무**: {row['주요 업무']}")
                    print(f"**지원 자격 및 우대사항**: {row['지원 자격 및 우대사항']}")
                    print(f"**근무 조건**: {row['근무 조건']}")
                    print(f"**모집 기간**: {row['모집 기간']}")
                    print(f"**지원 방법**: {row['지원 방법']}")
                    print(f"**기타 사항**: {row['기타 사항']}")
                    print("-----------------------------")

    def show_success_stories(self):
        """합격자소서 출력"""
        # 이 코드에서는 특정 기업의 합격자소서를 사용자에게 제공하기 위해 사용되었습니다.
        target_companies = ["현대자동차", "넥슨", "LG생활건강", "롯데마트", "삼성전자", "아모레퍼시픽", "기아"]
        sector_data = self.manager.sector_data
        # 합격자소서가 제공되는 기업만 필터링합니다.
        available_companies = [c for c in target_companies if c in sector_data['기업명'].unique()]

        print("\n합격자소서를 보고 싶은 기업을 선택하세요:")
        # 사용자가 선택할 수 있도록 제공 가능한 기업을 출력합니다.
        company = self.get_user_input("기업을 선택하세요:", available_companies)
        if company:
            # 선택된 기업의 합격자소서 데이터를 가져옵니다.
            details = sector_data[sector_data['기업명'] == company]
            story = details.iloc[0].get('합격자소서', '합격자소서 데이터가 없습니다.')
            print(f"\n===== [{company}] 합격자소서 =====")
            print(story)  # 선택된 기업의 합격자소서를 출력합니다.

    def start(self):
        """메인 실행 루프"""
        # 이 코드에서는 사용자가 원하는 기능을 선택하고 실행할 수 있도록 메뉴를 제공합니다.
        while True:
            # 사용자가 종료를 선택할 때까지 반복적으로 실행됩니다.
            print("\n1. 분야별 취업 정보 요약")
            print("2. 기업별 채용 공고")
            print("3. 기업별 합격자소서 보기")
            print("4. 종료")

            choice = input("\n원하는 기능의 번호를 입력하세요: ")
            if choice == '1':
                # 사용자가 분야별 요약 정보를 선택했을 때 실행됩니다.
                self.show_sector_summary()
            elif choice == '2':
                # 사용자가 기업별 채용 공고를 선택했을 때 실행됩니다.
                self.show_company_jobs()
            elif choice == '3':
                # 사용자가 합격자소서를 선택했을 때 실행됩니다.
                self.show_success_stories()
            elif choice == '4':
                # 사용자가 프로그램 종료를 선택했을 때 실행됩니다.
                print("프로그램을 종료합니다.")
                break  # 프로그램을 종료합니다.
            else:
                # 사용자가 잘못된 입력을 했을 경우 경고 메시지를 출력합니다.
                print("유효한 번호를 입력해주세요.")

# 실행 파일 경로 설정
# 이 코드에서는 데이터를 읽기 위해 전체 취업 정보와 분야별 취업 정보 파일 경로를 설정합니다.
main_file_path = '/content/sample_data/취업.csv'
file_paths = {
    "제조 및 생산 기업": "/content/sample_data/제조 및 생산 기업.csv",
    "데이터분석 기업": "/content/sample_data/데이터분석 기업.csv",
    "물류 및 SCM기업": "/content/sample_data/물류 및 SCM기업.csv",
    "IT 및 기술 개발 기업": "/content/sample_data/IT 및 기술 개발 기업.csv",
    "서비스 및 영업 기업": "/content/sample_data/서비스 및 영업 기업.csv",
    "경영 지원 및 컨설팅 기업": "/content/sample_data/경영 지원 및 컨설팅 기업.csv",
    "마케팅 및 기획 기업": "/content/sample_data/마케팅 및 기획 기업.csv",
}

# 데이터 관리 객체를 생성하고 데이터를 불러옵니다.
# 이 코드에서는 데이터를 준비하고, 사용자에게 필요한 정보를 제공하기 위해 JobDataManager를 사용합니다.
manager = JobDataManager(main_file_path, file_paths)
manager.load_data()

# 사용자 인터페이스 객체를 생성하고 프로그램을 시작합니다.
# 이 코드에서는 사용자가 메뉴를 통해 데이터를 탐색하고 원하는 정보를 선택할 수 있도록 JobAssistant를 사용합니다.
assistant = JobAssistant(manager)
assistant.start()
